---
title: '【题解】POJ-1182 食物链'
date: 2022-04-28 23:30:00
tags: 
	- ACM
	- 图论
desc: FZUACM2020新生训练-图论C,POJ1182
categories:
	- POJ题解

---
# POJ-1182 食物链

POJ：http://poj.org/problem?id=1182

## 题目

> 题目描述：
>
> 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。
> 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。
> 有人用两种说法对这N个动物所构成的食物链关系进行描述：
> 第一种说法是"1 X Y"，表示X和Y是同类。
> 第二种说法是"2 X Y"，表示X吃Y。
> 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
> 1） 当前的话与前面的某些真的话冲突，就是假话；
> 2） 当前的话中X或Y比N大，就是假话；
> 3） 当前的话表示X吃X，就是假话。
>
> 任务描述：
>
> 根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数。

| Time Limit | Memory Limit |
| ---------- | ------------ |
| 1000ms     | 10000 kB     |

## 思路

首先我要跟自己严肃批评一下，这是一道非常经典的并查集题，出现在NOI2001，但是我并没有做过

### 处理信息

题目本身就有很强的并查集提示，但是我们仍然需要解决一个问题：如何确定每种动物属于A、B还是C？我们再想一下，我们真的需要确定这个动物确切属于ABC的哪一个吗？更直接一点，为什么要出现ABC？

对于这个环形食物链，我们任意选取其中一种动物，我们可以观察到，**这种动物**和另外两种的关系，**必定只存在一个吃和一个被吃**。这样子我们可以稍微简化一下，需要实现的关系从ABC变到了吃和被吃的关系。

但是上述表达仍然，存在一些问题，我们仍然刻意强调了**这种动物**这个概念，我们需要继续减弱这种概念的影响，我们继续简化，对于一个动物（不是一类动物）本身而言，**它和别的动物只会存在下面三种关系**：同类、被吃、吃

### 更新时关系的更新

我们设定一个`pair<long long ,long long> node[MAXN]`，规定为一个节点的表示，其中，first表示这个节点的根节点位置，second表示这个节点与根节点的关系（吃、被吃、同类）

在更新父节点的过程中，我们与父节点的关系也会发生变化，现在我们需要考虑的就是如何更新我们与父节点的变化，这里我们假设存在三个节点：`x->y->z`在更新过程中，我们肯定是期望要直接把x的父节点更新为z，但是如何确定x和z的关系？直接枚举

| x->y | y->z | x->z     | 由x->y推x->z                           |
| ---- | ---- | -------- | -------------------------------------- |
| 同类 | 同类 | 同类     | 同类+同类=同类                         |
| 同类 | 吃   | 吃       | 同类+吃=吃                             |
| 同类 | 被吃 | 被吃     | 同类+被吃=被吃                         |
| 吃   | 同类 | 吃       | 吃+同类=吃                             |
| 吃   | 吃   | **被吃** | 吃+吃=被吃（因为这是一个环状食物链）   |
| 吃   | 被吃 | 同类     | 吃+被吃=同类                           |
| 被吃 | 同类 | 被吃     | 被吃+同类=被吃                         |
| 被吃 | 吃   | 同类     | 被吃+吃=同类                           |
| 被吃 | 被吃 | 吃       | 被吃+被吃=吃（因为这是一个环状食物链） |

注意：这是任意的三个点之间的关系，一共只有9种

我们进行如下抽象：`同类=0，被吃=1，吃=2`，或者`同类=0，吃=1，被吃=2`，之所以我一直把同类定义为0，因为由表格第一行，`同类+同类=同类`，**在数学上这与0的性质很接近**

继续观察我给了备注的两行，我们可以发现`吃+吃=被吃`和`被吃+被吃=吃`如果根据上面抽象化（以第一个为例），就是`2+2=1`和`1+1=2`，第二个抽象在数学上本身成立，那如何让第一个也成立呢？我们引入了模：`(2+2)%3=1`，引入后经过检查，不会与其他关系冲突，也就是说，我们可以在以上9种的关系中全部加入模3（也可以根据题目猜测得出，因为题目也是一个**有3种动物的环状食物链**）。

因此，我们得出了一个公式用于解决节点状态更新的问题

$$ Relation<x,z> = (Relation<x,y>+Relation<y,z>)\%3 $$

### 合并时状态的更新

除了更新父节点，我们还需要解决两棵树合并的问题，现在考虑两个节点`x和y`，他们的根节点不同（`假定为fx和fy`），我们合并时选择`把y树合并到x树上`，为了简化问题，我们让这些点之间的关系为`aniType-1`（因为恰好可以与前面讨论的内容直接成立，输入1时表示的就是同类，2表示的就是吃的关系）

合并两棵树，实际上只需要解决`fy节点连接到fx节点的状态更新`，接着，我们发现这四者其实存在一些关系：`y->fy,x->y,x->fx`可以发现，跟前面关系更新时非常的像：

`y->fy`的关系实际上就是`fy->y`的关系取反（比如吃变为被吃），同类->同类（0->0），吃->被吃（1->2），被吃->吃（2->1），我们可以发现对于后面二者，我们直接改为`3-Relation<fy,y>`，但是这时候我们会发现如果是同类的话这个公式最后答案是3，等一下，直接模3不就好了吗？这不又变回0了？

其他就是一个顺水推舟了，我们可以得到一个新的公式

$$ Relation<fy,fx> = (-Relation<y,fy> + Relation<y,x>+Relation<x,fx>)\%3$$

至此，代码已经显而易见了，我们只需要在**每次更新**时利用如上关系同时更新两个节点间的联系即可

**注意：是每次更新，并查集在进行set_union()和set_find()过程中都会进行更新，同时，在代码中，每调用一次这两个函数，节点间关系都有可能会改变，因此不能储存find()的ans，先前为了减少工作量，在main()函数中我储存了find的结果，直接导致本来AC的这道题WA了7个测点**

## 代码

```c++
/**
 * @author OZLIINEX
 * @brief POJ - 1182  食物链
 * @date 2022-04-28
 */

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>

#define MAXN 100001

using namespace std;

typedef long long ll;

pair<ll, ll> node[MAXN]; // first：根节点位置 second:与根节点的关系（0=同类，1=吃，2=被吃）

/**
 * @brief 构建
 */
void makeSet(ll n)
{
    for (int i = 1; i <= n; i++)
    {
        node[i].first = i;
        node[i].second = 0; //跟自己肯定是同类拉
    }
}

/**
 * @brief 查找x所在树的根节点，并不断更新这棵树
 */
ll find(ll x)
{
    ll fx = node[x].first; //拿到这个点的父节点
    if (x != fx)
    {
        node[x].first = find(fx);                                //持续更新这个节点的父节点
        node[x].second = (node[x].second + node[fx].second) % 3; //更新这个节点和父节点的关系
    }
    return node[x].first;
}

void Union(ll x,ll y,ll d){
    ll fx = find(x);
    ll fy = find(y);

    node[fy].first = fx;
    node[fy].second = (node[x].second - node[y].second + 3 + (d - 1)) % 3; //更新节点关系
}

int main()
{
    ll n, k;
    ll aniType, aniX, aniY; //种类，动物1和2  1=同类 2=X吃Y
    ll ans = 0;
    scanf("%lld %lld", &n, &k);
    makeSet(MAXN - 1);
    while (k--)
    {
        scanf("%lld %lld %lld", &aniType, &aniX, &aniY);

        //当前的话中X或Y比N大 或 当前的话表示X吃X
        if (aniX > n || aniY > n || (aniX == aniY && aniType == 2))
        {
            ans++;
            continue;
        }
        if (find(aniX) == find(aniY)) //判断这两棵树的根节点是否一样，若不一样则执行合并操作，一样则进行相应判断
        {
            if (aniType == 1 && node[aniX].second != node[aniY].second) //同类但是两个根节点不同，false
                ans++;
            if (aniType == 2 && (node[aniX].second + 1) % 3 != node[aniY].second) //a吃b但是二者
                ans++;
        }
        else Union(aniX,aniY,aniType);
    }

    printf("%lld\n", ans);//
    return 0;
}
```



## Reference

https://blog.csdn.net/freezhanacmore/article/details/8767413