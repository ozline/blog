---
title: 并查集
date: 2021-10-17 01:37:43
tags: ACM
---

# 并查集

2018.10.04

- 并查集保持一组不相交的动态集合$S={S1,S2...Sk}$。
- 每个集合通过一个代表来识别
- 代表就是集合中的某个成员
- 哪一个成员作为代表是无所谓的
- 我们关心的是如果寻找某一动态集合的代表2次，并且在两次寻找之间不修改集合，两次得到的答案应该是相同的

# 操作

### Make-Set(x)

建立一个新的集合，它的唯一成员，也就是代表，就是x

因为各个集合是不相交的，所以要求x在其他集合中没有出现过

### Union(x,y)

将包含x和y的动态集合合并并为一个新的集合（就是这两个集合的并集）

假定在这个操作之前两个集合是不相交的，然后选出一个代表

### Find-Set(x)

返回一个指针，指向包含x的（唯一）集合代表

# 应用

简单：统计一个无向图中连通子图的个数

对于每个V中的顶点v，Make-Set(v)

对于每个E中的边(u,v)，如果Find-Set(u)!=Find-Set(v)，则Union(u,v)

最后统计有几个集合就可以了。（统计代表的个数）

# 如何实现

用有根树来表示集合

树中的每个节点都表示集合的一个成员

每棵树表示一个集合

每个成员仅指向它的父节点

每棵树的根表示代表，而且它的父亲是它自己（父节点是自己）

之前的三个操作：

- Make-Set(x):一颗新的树
- Union(x,y):让一棵树的根指向另一棵树
- Find-Set(x):查找根节点（树根）

# 优化

### 按秩合并

目的是让包含较少节点的树的根指向包含较多节点的树的根



不记录以每个节点为根的子树的大小

采用一种简化分析的方法

对每个节点，用秩(rank)表示节点高度的一个上界

在按秩合并过程中，具有较小的根在Union操作中要指向具有较大秩的根

### 路径压缩

目的是减少Find-Set操作中访问的节点个数



尽量让路上每个节点直接指向根节点

这个操作不会改变节点的秩

# 代码实现

$p[x]$表示x的父节点，$rank[x]$表示x的秩

### Make-Set(x)

```c++
p[x]=x
rank[x]=0
```

Link过程是由Union调用的一个子过程

### Union(x,y)

```
Link(Find-Set(x),Find-Set(y));
```

### Link(x,y)

```c++
if(rank[x]>rank[y]) p[y]=x;
else{
    p[x]=y;
    if(rank[x]==rank[y]) rank[y]+=1;
}
```

### Find-Set(x)

```c++
if(x!=p[x]) p[x]=Find-Set(p[x]);
return p[x];
```

这中间包含了路径压缩

第一趟（递归没有收缩） 查找一路上升，并且找到根

第二趟（递归收缩）更新每一个节点，让节点直接指向根

# 时间复杂度计算

当同时使用按秩合并和路径压缩时，最坏情况运行时间为$$O(mα(n))$$，其中$α(n)$ 是一个增长极其缓慢的函数。

在各种实际情况中，可以把这个运行时间看作与m 成线性关系。